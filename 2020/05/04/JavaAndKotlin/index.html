
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>开发效率 - Kotlin - Lollipop</title>
    <meta name="baidu-site-verification" content="lGVNqFPfNO" />
    <meta name="google-site-verification" content="sm3JfidSJFBpLMJ5iPEwXzBiGID7DzfiKlJaktGdgIo" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Lollipop,"> 
    <meta name="description" content="A simple blog site,日常工作中，我们总是希望提高效率，比如快捷键、自动化等，其实开发语言本身在兼容的情况下，也是可以提高效率的。比如Java的lambda表达式。这里介绍的Kotlin，并不是为了介绍Kotlin语言的,"> 
    <meta name="author" content="Lollipop"> 
    <link rel="alternative" href="atom.xml" title="Lollipop" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">Lollipop</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://lollipoppp.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">开发效率 - Kotlin</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">开发效率 - Kotlin</h1>
        <div class="stuff">
            <span>五月 04, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E2%80%9CAndroid%E2%80%9D/" rel="tag">“Android”</a></li></ul>


        </div>
        <div class="content markdown">
            <p>日常工作中，我们总是希望提高效率，比如快捷键、自动化等，其实开发语言本身在兼容的情况下，也是可以提高效率的。比如<code>Java</code>的<code>lambda表达式</code>。<br>这里介绍的<code>Kotlin</code>，并不是为了介绍<code>Kotlin</code>语言的入门或者使用方式，而是和<code>Java</code>对比，说明<code>Kotlin</code>提高效率的方面，下面会用一些小例子，说明一下日常开发中的小提升。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p><code>Kotlin</code>会被编译为<code>Java</code>字节码，并且可以指定<code>Java</code>版本，这样一来，对于需要运行指定版本<code>Java</code>代码的环境来说，就非常友好了。</p>
<h3 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h3><p>在<code>Kotlin</code>的代码中是可以直接调用<code>Java</code>类的方法的，因此对于老项目改造是很友好的。<br>而<code>Java</code>中也可以直接使用<code>Kotlin</code>的类以及方法，虽然使用的时候看起来有点奇怪，但是还是可以直接兼容的，因此对于老项目的升级，是没有问题的。</p>
<h2 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h2><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在<code>Kotlin</code>中，申明变量是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sdf = SimpleDateFormat(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">var</span> sdf2 = SimpleDateFormat(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，前面就一个<code>val</code>或者<code>var</code>，看起来像是<code>JavaScript</code>的弱类型啊，其实并不是。<br><strong>当申明变量并且直接初始化为明确类型的值时，可以自动推导类型，不用指定类型。</strong><br>换句话说，有下面的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个Int值</span></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="comment">// 申明一个Lang值</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写就不行啦，因为变量的申明，要么可以推导确定类型，要么指定类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 可以改成这样</span></span><br><span class="line"><span class="keyword">var</span> temp: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>你可能会说，这个好像也没多大区别吧，但是对于下面这两种场景呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">MainFragment.LoadCallback loadCallback = <span class="keyword">new</span> MainFragment.LoadCallback() &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">OutputStream out = xxx.getOutputStream();</span><br></pre></td></tr></table></figure>
<p>这时候就很不友好了，每次接受一个对象需要写一遍类型再写名字。如果同样的内容换成<code>kotlin</code>呢?</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sdf = SimpleDateFormat(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> loadCallback = <span class="keyword">object</span>: MainFragment.LoadCallback() &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">out</span> = xxx.getOutputStream();</span><br></pre></td></tr></table></figure>
<p>这样是不是就友好很多？<br>尽管编译器的<code>.var</code>快捷命令，可以帮助我们申明类型，但是它代码本身就在那里，还是会影响视觉。</p>
<blockquote>
<p><code>val</code>及<code>var</code>的区别请前往中文官网自行查看。<br>另外，<code>Java</code>高版本也支持了类型推导，但是个人认为没有<code>Kotlin</code>做得好，而且有版本兼容问题。</p>
</blockquote>
<hr>
<h3 id="非空判断"><a href="#非空判断" class="headerlink" title="非空判断"></a>非空判断</h3><p><code>Java</code>中写的最多的，可能就是判空吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">    a.b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量赋值</span></span><br><span class="line">String b = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">    b = c.d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在好消息是，<code>Kotlin</code>里面可以大幅度的省略这部分代码了！<br>这分为两部分：类型非空，空判定</p>
<h4 id="类型非空"><a href="#类型非空" class="headerlink" title="类型非空"></a>类型非空</h4><p>上一个小节里面，指定变量类型的时候，在类型名称后面加上了一个<code>?</code>，就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>这就是类型非空了，当一个变量申明时，如果变量类型后面携带了<code>?</code>，或者类型推导时发现内容可能为<code>null</code>，那么就会在调用时直接报错或者发出警告。提示你对象可能为<code>null</code>，怎么调用这些可能为null的对象，是下一个标题的内容。<br>相反的，如果申明时没有携带<code>?</code>，那么它就认为这个变量是不能赋值为<code>null</code>的，如果你在后续的赋值中，赋值了<code>null</code>，就会自己报错，连编译都过不了，就算侥幸<code>骗过</code>了编译，也会在运行时赋值为<code>null</code>的时候直接报错。<br>这样可以一定程度上避免代码单元内的空指针问题，也可以一定程度尽早发现空指针问题，同样，也少了很多的非空判断</p>
<h4 id="空判定"><a href="#空判定" class="headerlink" title="空判定"></a>空判定</h4><p>上面说的是类型指定，那么使用呢？如果一个可能为<code>null</code>的对象怎么使用？加<code>if</code>？不用，可以直接这样写：（沿用小节开头的<code>Java</code>例子）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">a?.b();</span><br><span class="line"><span class="comment">// 变量赋值</span></span><br><span class="line"><span class="keyword">val</span> b = c?.d()?:<span class="string">""</span>;</span><br><span class="line"><span class="comment">// 参数判断</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">A</span>?)</span></span> &#123;</span><br><span class="line">    a?:<span class="keyword">return</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面列举了三种常见的场景。<br>对于对象的方法调用，直接加上一个<code>?</code>即可，等价于上面的<code>if</code>中调用。<br>对于参数的赋值，可以在后面添加默认值，使用的是<code>?:</code>。<br>对于方法内的参数判断，可以直接使用像是赋值一样的写法，然后执行<code>return</code>操作。<br>代码是不是就简单了很多？</p>
<h2 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="Getter &amp; Setter"></a>Getter &amp; Setter</h2><p><code>Kotlin</code>帮我们做了很多的默认实现，这让我们的代码写起来更加轻松。<br>按照Java规范，我们写一个数据类一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">(String a, String b, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">""</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略toString及equals方法的重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，尽管只有三个成员变量，但是一个类还是非常的长，尽管有编译器的一键生成，但是代码仍然很多，不是很友好，而且全都是非常机械非常模板化的代码。那么在<code>Kotlin</code>中会是什么效果，简化会达到什么程度呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>(<span class="keyword">var</span> a: String = <span class="string">""</span>, <span class="keyword">val</span> b: String = <span class="string">""</span>, <span class="keyword">var</span> c: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>是不是感觉有点离谱？这里可以告诉你的是：确实已经写完了一个<code>Bean</code>。那么它符合<code>Java</code>规范吗？它是符合的，只是简化了这个过程，class的前面加上了<code>data</code>，表示这是一个数据类，<code>Kotlin</code>会自动为我们根据成员变量生成<code>toString</code>和<code>equals</code>等方法，我们也可以选择重写它，如果不需要特别重写，那么我们连类的大括号都不用写。<br>上面的<code>Java</code>代码中，<code>b</code>是不能被赋值的，这里只要把<code>var</code>改成<code>val</code>就好了。而<code>getter</code>和<code>setter</code>呢?<br><code>Kotlin</code>中的每个变量都默认有个<code>getter</code>和<code>setter</code>的实现，也就是都帮我们写好了默认实现。<br>而成员变量的申明，因为变量会在构造器赋值，所以只要在构造器的参数中加上变量前缀，就自动变成了成员变量，当然，还可以前缀一个<code>private</code>，让这个变量只能内部可见。<br>那么又有另一个问题了，三个参数都有默认值，我只想设定其中两个怎么办？<code>Java</code>上的做法就只有提供足够多的重载了，但是<code>Kotlin</code>里面可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bean = Bean(a = <span class="string">"hello"</span>, c = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，还可以直接使用变量名指定传值，这样连重载也不用了。<br>但是这里要说明一点，如果是需要反射调用的方法或者构造器，是需要单独申明的，否则是找不到的，毕竟参数数量本身没有变。</p>
<p>另一个方面，上面说了，<code>Kotlin</code>帮我们写好了<code>getter</code>和<code>setter</code>，那么我们能重写吗？请看下面的例子:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> colorArray = intArrayOf(Color.RED, Color.GREEN, Color.BLUE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> color: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> colorArray[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            colorArray[index] = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        index++</span><br><span class="line">        index %= colorArray.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 就像直接普通变量一样使用，完全感知不到getter方法</span></span><br><span class="line">    <span class="keyword">val</span> index = a.index</span><br><span class="line">    <span class="comment">// 报错，提示找不到设置的方法</span></span><br><span class="line">    <span class="comment">// a.index = 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 就像常规变量一样获取</span></span><br><span class="line">    <span class="keyword">val</span> color = a.color</span><br><span class="line">    <span class="comment">// 直接对变量赋值，其实是走到了setter方法</span></span><br><span class="line">    a.color = Color.PINK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们的<code>A</code>中维护了一个颜色数组，提供了一个方法来移动下标。<br>外部可以拿到下标，也可以通过一个叫<code>color</code>的变量来获取和设置当前下标对应的颜色。但是我们其实没有<code>color</code>这个成员变量，我们只是通过完全重写<code>getter</code>和<code>setter</code>来模拟了一个变量。</p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>都说<code>Kotlin</code>是语法糖，但是这糖也是真的甜。比如这里介绍的<code>扩展方法</code>。<br>它其实不是真的为对象类型增加了方法，只是从语法上做到了效果而已，但是使用的时候却可以大大提升效率。<br>举个<code>Java</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个int转换为字符串的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">formatInt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = formatInt(</span><br><span class="line">            object1.funB(</span><br><span class="line">                object2.funC())</span><br><span class="line">            .funD());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的例子，但是看起来就不是很友好了，业务场景可能还会有更麻烦的结构。你可能会说多申明几个变量，然后分开写，但是那样又会显得很臃肿，写起来没有这种链条一样调用的爽快感觉。<br>所以可以这么写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个int转换为字符串的方法</span></span><br><span class="line"><span class="keyword">private</span> fun Int.format(): String &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0$i"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"$i"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">funA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val str = object1.funB(object2.funC())</span><br><span class="line">                        .funD()</span><br><span class="line">                        .format()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个扩展方法就像它原本就有的方法一样，可以直接调用，完美的混入了<code>链条</code>中。<br>而使用是，方法的增加和去掉，也不用像以前一样，考虑左边括号到哪里，右边括号是哪一个了。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><code>Java</code>中是先有<code>Class</code>再有方法，也就是必须要有对象。而在<code>Kotlin</code>中，也是面向对象，但是它可以有顶级函数，也就是不依托于<code>Class</code>的函数，当然，这也是语法糖而已。但是使用效果非常不错，我们先举例子再说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler mainHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAsync</span><span class="params">(ErrorCallback err, RunCallback run)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Task(err, run));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onUI</span><span class="params">(ErrorCallback err, RunCallback run)</span> </span>&#123;</span><br><span class="line">        mainHandler.post(<span class="keyword">new</span> Task(err, run));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> ErrorCallback errorCallback;</span><br><span class="line">        <span class="keyword">private</span> RunCallback runCallback;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(ErrorCallback e, RunCallback r)</span> </span>&#123;</span><br><span class="line">            errorCallback = e;</span><br><span class="line">            runCallback = r;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runCallback.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errorCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    errorCallback.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">RunCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">""</span>;</span><br><span class="line">                </span><br><span class="line">        TaskUtil.doAsync(<span class="keyword">null</span>, <span class="keyword">new</span> TaskUtil.RunCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 子线程</span></span><br><span class="line">                ...</span><br><span class="line">                Test.<span class="keyword">this</span>.testB(str);</span><br><span class="line">                TaskUtil.onUI(<span class="keyword">null</span>, <span class="keyword">new</span> TaskUtil.RunCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="comment">// UI线程</span></span><br><span class="line">                        Test.<span class="keyword">this</span>.testB(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">(String str)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的线程同步的工具类以及调用示例，可以看到，尽管简化了一部分代码，但是使用时的调用仍然非常繁琐，而且会存在上下文问题（回调函数中的<code>this</code>到底是哪个<code>this</code>?。那么<code>Kotlin</code>里面呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadPool: Executor <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Executors.newCachedThreadPool()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mainHandler: Handler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler(Looper.getMainLooper())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: Any&gt;</span> T.<span class="title">doAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">noinline</span> err: ((<span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">noinline</span> run: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    threadPool.execute &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            run.invoke(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            err?.invoke(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: Any&gt;</span> T.<span class="title">onUI</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">noinline</span> err: ((<span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">noinline</span> run: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    mainHandler.post &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            run.invoke(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            err?.invoke(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">""</span></span><br><span class="line">        doAsync &#123;</span><br><span class="line">            <span class="comment">// 子线程中</span></span><br><span class="line">            testB(str)</span><br><span class="line">            onUI &#123;</span><br><span class="line">                <span class="comment">// UI线程中</span></span><br><span class="line">                testB(str)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testB</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对比效果非常明显。<strong>调用简单</strong>而且<strong>结构清晰</strong>。<br>那么，现在来说解释一下，上面用到了哪些东西。</p>
<h3 id="顶级函数"><a href="#顶级函数" class="headerlink" title="顶级函数"></a>顶级函数</h3><p>顶级函数，也就是前面方法申明的时候，外面没有套一层<code>Class</code>，减少了类的约束，成为了全局的方法。<code>Kotlin</code>中的<code>Math</code>类也是这样的，相比<code>Java</code>中的<code>Math</code>，调用时可以直接写作<code>min(a, b)</code>，不用加上类名。</p>
<h3 id="内联-inline"><a href="#内联-inline" class="headerlink" title="内联 inline"></a>内联 inline</h3><p>它的作用类似于我们日常中的封装，但是又和我们的封装有些不一样。我们遇到多次出现但是内容一样的代码时，一般都是抽取并且包装成一个方法，如果是多个类共用，那么可能还要再抽取一个类出来，尽管方法实现还是那样的，但是毕竟还是抽了个方法出来，可能还跨了类调用，方法寻址还是需要时间的。<br>而内联的作用与它类似，但是它是反过来的，当编译时，会把内联方法的代码整个复制到调用的地方，然后顺便做一下结构优化，这样就满足了我们的本来目的，一次写多份代码。</p>
<h3 id="reified"><a href="#reified" class="headerlink" title="reified"></a>reified</h3><p>这个关键一般是配合<code>inline</code>使用的，从含义上来讲，是<code>使它更真实</code>，我的理解就是推导泛型。<br>上面讲过了，编译时内联代码是以复制的形式贴到调用的地方的，而这个时候，如果方法存在泛型，那么基本上都是可以直接明确类型的，而这个关键字就是做这个的。<br>它可以避免泛型和类型强转引发的安全隐患，也可以实现另类的重载。</p>
<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>在<code>Kotlin</code>一切函数皆可<code>lambda</code>，可以直接拿到函数的引用，然后在必要时调用，就像上面的<code>run.invoke()</code>。<br>而在使用是，由于表达式的特性，直接使用大括号就好了，也省了很多事情，不用反复申明接口，<code>new</code>对象。<br>甚至，可以通过<code>::</code>来获取对象中的函数引用，只要函数，不要对象，使用和传递过程也少了很多限制。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>就是上面申明线程池的那个关键字<code>by lazy</code>，它要求变量必须是<code>val</code>，其实就是帮我们做了在<code>get</code>的时候调用后面的表达式实例化对象，然后后面一直使用这个对象，就像帮我们做了个小单例。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><code>Kotlin</code>还有很多特性，比如<code>协程</code>、<code>委托</code>等等，但是太多了，所以就不添加进来了，只写了日常代码用的比较多的部分。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='83769e11ad8dee614a88'
        data-cs='3de1ef474db139cd0f47e8769f5afed5db7da651'
        data-r='blogTalk'
        data-o='lollipoppp'
        data-a='lollipoppp'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#兼容性"><span class="toc-number">1.</span> <span class="toc-text">兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#版本"><span class="toc-number">1.1.</span> <span class="toc-text">版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向"><span class="toc-number">1.2.</span> <span class="toc-text">双向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型处理"><span class="toc-number">2.</span> <span class="toc-text">类型处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型推导"><span class="toc-number">2.1.</span> <span class="toc-text">类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非空判断"><span class="toc-number">2.2.</span> <span class="toc-text">非空判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型非空"><span class="toc-number">2.2.1.</span> <span class="toc-text">类型非空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空判定"><span class="toc-number">2.2.2.</span> <span class="toc-text">空判定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getter-amp-Setter"><span class="toc-number">3.</span> <span class="toc-text">Getter &amp; Setter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展方法"><span class="toc-number">4.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程"><span class="toc-number">5.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#顶级函数"><span class="toc-number">5.1.</span> <span class="toc-text">顶级函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内联-inline"><span class="toc-number">5.2.</span> <span class="toc-text">内联 inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reified"><span class="toc-number">5.3.</span> <span class="toc-text">reified</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数引用"><span class="toc-number">5.4.</span> <span class="toc-text">函数引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒加载"><span class="toc-number">5.5.</span> <span class="toc-text">懒加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束语"><span class="toc-number">6.</span> <span class="toc-text">结束语</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-153109857-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
