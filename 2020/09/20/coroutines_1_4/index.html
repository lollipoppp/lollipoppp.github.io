
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>协程的初次尝试与学习 - Lollipop</title>
    <meta name="baidu-site-verification" content="lGVNqFPfNO" />
    <meta name="google-site-verification" content="sm3JfidSJFBpLMJ5iPEwXzBiGID7DzfiKlJaktGdgIo" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Lollipop,"> 
    <meta name="description" content="A simple blog site,
本文内容基于Kotlin 1.4，可能存在更低版本不包含的新特性或语法，可能存在更高版本已抛弃的语法或API。
你可以通过Gradle引入
1implementation &#39;org.jetbrai,"> 
    <meta name="author" content="Lollipop"> 
    <link rel="alternative" href="atom.xml" title="Lollipop" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">Lollipop</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://lollipoppp.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">协程的初次尝试与学习</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">协程的初次尝试与学习</h1>
        <div class="stuff">
            <span>九月 20, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E2%80%9CAndroid%E2%80%9D/" rel="tag">“Android”</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p>本文内容基于<code>Kotlin 1.4</code>，可能存在更低版本不包含的新特性或语法，可能存在更高版本已抛弃的语法或API。</p>
<p>你可以通过<code>Gradle</code>引入</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.0-RC1'</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>尽管<a href="https://www.kotlincn.net" target="_blank" rel="noopener">kotlincn.net</a>中已经有非常详细的文档了，但是个人感觉还是没有找到重点，就像一篇文章不知道它的中心思想一样，每一个用例感觉都懂了，但是又感觉都没有懂。所以这里留下个人学习的笔记。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>Kotlin-JVM</code>由于Java的局限性，是没有办法做到类似于<code>Go</code>语言的协程的，而官网也承认了，这只是基于<code>Java</code>线程池的轻量级线程。<br>翻译过来，可以理解为，利用线程池，在线程基础上再次包装了一个<code>协程</code>任务框架。就像<code>Runnable</code>对于<code>Thread</code>的关系一样，但是它包含了更多的逻辑，可以抛开线程的概念，是一个异步任务的框架。这样理解，可能会更加清晰一些了。</p>
<h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><h5 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h5><p>名字直译过来是<code>协程域</code>，可以理解为，这是一个管理器，一个容器。协程必须要在域内才能运行，并且域有义务管理协程的生命周期，做到最基本的等待以及取消协程等工作，就像<code>ViewGroup</code>一样。<br>它可以被继承，然后来实现不同场景的效果，它也是可以嵌套的。</p>
<h5 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h5><p>名字直译可以是<code>作业</code>，个人感觉理解成“任务”也是可以的，它表示一个协程，当创建一个协程时，就会得到一个<code>Job</code>对象，它代表了协程对象，可以用它来一定程度上控制协程。比如取消协程。但是注意，尽管官网没有重点提醒，但是这里需要重点说明一下。<strong>协程所谓的取消，指的是任务开始前取消执行，如果任务在运行过程中（CPU占用中）。那么是不能被取消的，也就是说，它本质上只是一个状态位，判定不通过的话不启动而已。因此，如果一个协程任务是可以被中止的，那么需要在任务中的逻辑节点中手动判定一下，任务内部又一个隐藏的变量<code>isActive</code>，如果它返回了False，那么表示协程被取消了，此时需要中断逻辑。另一方面，协程中断某些逻辑性任务时，会抛出一个任务取消的异常，那么也可以理解为，协程的中断依赖于Java的异常机制。</strong></p>
<p>任务的创建可以在<code>协程域</code>之外，也有多种创建方式，但是最终的运行，仍然需要在域中。</p>
<h5 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h5><p>名字直译可以理解为<code>协程上下文</code>，它是表示协程的行为集合，包括</p>
<ul>
<li><code>Job</code>的生命周期</li>
<li><code>CoroutineDispatcher</code>协程调度器的指定</li>
<li><code>CoroutineName</code>协程名称，主要用于调试</li>
<li><code>CoroutineExceptionHandler</code>协程异常处理器，主要处理未捕获的异常</li>
</ul>
<p>它会存在于<code>Job</code>中，他默认会从环境(域)中继承，并且在创建时确定下来。它可以<code>Job</code>创建时额外指定，以此来切换线程。</p>
<h5 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h5><p>从名字来看，是<code>协程调度器</code>，它的用处，其实更加明确的说法是：“指定协程运行的线程池”。是的，是线程池，这里需要说到一个注意点，协程是线程之上的结构化任务管理，那么它就希望使用者尽量抛弃线程概念，同时尽可能复用资源，那么就会存在一个可怕的事情，协程经过一次<code>挂起</code>，可以立即为“暂停”，那么下次继续运行的时候，极大可能就会变成了另一个线程，如果协程运行过程中，将一些数据关联到协程之外的线程上，那么数据可能就不在了，同时，如果运行时，通过线程信息来标示任务，那么也可能因为线程的切换导致标记失效。<br>同样，如果使用了错误的调度器，那么也会导致一些奇怪的问题发生，一般情况下，<code>IO</code>调度器，主要用于执行一些网络访问，数据库读写，文件读写等与读写有关的操作，据文档所说，协程会在一定程度上优化这个过程。而内存中的常规计算或者解析，比如<code>Json</code>的解析，排序，高斯模糊等，就建议在<code>Default</code>中了，他主要针对CPU计算做了些优化。</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>协程的结构，可以根据他们的表现特性，来组建一下层次。<br>这里我说一下我的理解，<code>协程域</code>管理一组协程，可以通过控制<code>域</code>来直接控制内部协程的取消与中止，还可以控制他们的开始时机等。<br>但是并不代表同一个<code>域</code>的协程在同一个线程池运行，它更像是一个业务层的管理者，而协程的运行线程，取决于<code>Job</code>创建时指定的调度器，然后帮我们做好了回调函数，来多个任务间切换，看起来就像同步一样。同样，每个<code>Job</code>中，又再次嵌套了别的<code>域</code>，这样，一个树状的协程结构就出来了。<br>尽管是包含关系的层次嵌套，但是因为运行线程不受这个结构约束，那么可以想象带来的好处就是，一个数据请求的业务需求，可以建立一个<code>域</code>关联图形界面的生命周期，当他关闭时，停止所有操作。接着，在这里<code>域</code>里面，创建网络连接的的任务，关联到<code>IO</code>调度器。再创建数据处理的任务，关联到<code>Default</code>调度器。因为协程的<code>挂起</code>能力，尽管同时创建，但是我们仍然可以让它在数据请求回来之后开始执行。最后数据处理结果返回，这时线程处于最初创建的<code>域</code>中，位于<code>UI</code>线程，我们可以刷新界面了。<br>上述结构，只是基于前面概念描述的猜想，但是能不能做到呢？我们需要实际分析一下。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>注意，此处标题我用的是<code>方法</code>，因为这些都不是<code>Kotlin</code>标准库中的关键字，而是<code>协程</code>扩展库中的顶级函数，看起来会像是关键字。</p>
<h5 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h5><p>从名字上看，这就是发射，启动的方法。它是<code>域</code>提供的方法，用途是创建并且启动一个协程任务，同时返回一个<code>Job</code>对象，但是需要注意的是，它类似于我们的线程池<code>execute</code>方法，它并不会有返回值，就只是单纯的启动了一个协程任务。<br>它可以在常规方法中启动。</p>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>名字来看，这是异步的意思，它也是<code>域</code>提供的方法，它的作用和<code>launch</code>相似，都是创建并且启动一个协程任务，但是它会存在返回值，也就是协程任务的返回值可以通过它的返回的对象取到。<br>它返回的是一个<code>Deferred</code>对象，可以通过它的<code>await()</code>方法，以阻塞的方式等待结果。<br>它不能从常规方法中启动。</p>
<h5 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h5><p>这是一个顶层的方法，主要用途是基于当前线程创建一个<code>域</code>。它的表现有以下几点：</p>
<ul>
<li>可以使用协程，不管是运行在当前线程还是其他线程</li>
<li>它具有<code>域</code>的基本特点，内部包含一个<code>loop</code>循环，保证方法不会在协程任务结束之前结束掉。（这在main方法中很有用）</li>
<li>它可以有返回值</li>
</ul>
<h5 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h5><p>这也是一个顶层函数，它主要用于协程中的挂起，它和线程的<code>sleep</code>是有区别的，它使用的是挂起，也就是说，不会一直占用线程。</p>
<h5 id="coroutineScope"><a href="#coroutineScope" class="headerlink" title="coroutineScope"></a>coroutineScope</h5><p>这是一个顶层方法，但是要求在一个<code>域</code>中执行，它会创建另一个<code>域</code>，可以理解为创建另一组任务。它将返回一个<code>域</code>对象，可以取消内部的全部协程任务。</p>
<h5 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h5><p>指定一个调度器来执行协程，并且会把结果作为返回值当作方法的返回值。它需要在<code>域</code>中使用，并且他是会使协程挂起。</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>这是一个协程中的表示当前任务让出线程，并且挂起。它类似于任务的重排，将任务放置到队列最后，直到有资源执行任务。让出挂起期间，可以被取消任务。<br>后遗症是，<code>yield</code>后的任务，可能运行在下一个线程中了。</p>
<h5 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h5><p>这是一个关键字，前缀在<code>fun</code>之前，用于表示这是一个协程挂起方法。但是只有在导入<code>协程</code>库之后，才会有效。它的表现是：</p>
<ul>
<li>可以在方法中直接使用协程中的方法。</li>
<li>只能在协程中调用这个方法</li>
<li>调用时，协程处于挂起状态，直到它执行完毕，产生返回值</li>
<li>如果方法中存在另一个协程方法，那么以此类推。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上面介绍的都是一些概念性的东西，现在尝试使用一下它们。</p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>我们使用<code>IDEA</code>来编写Demo，记得项目建好后，导入<code>协程</code>仓库，就在文章开头。<br>首先，我们需要创建一个main方法，由于上面内容可以知道，协程需要在<code>域</code>中，我们需要一个<code>域</code>。我们可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>runBlocking</code>在主线程创建一个<code>域</code>，并且它自带了<code>loop</code>，我们可以不用担心协程在异步过程中，应用程序结束了。</p>
<p>接着，我们尝试让它做一个异步任务，就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch &#123; <span class="comment">// 在后台启动一个新的协程并继续</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 非阻塞的等待 1 秒钟（默认时间单位是毫秒）</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 在延迟后打印输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 协程已在等待时主线程还在继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是官网上的demo，它会在<code>域</code>中启动任务，并且等待全部执行完毕后关闭。<br>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>这里，我尝试了不按照官网的方式来写。比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    GlobalScope.launch() &#123; <span class="comment">// 在后台启动一个新的协程并继续</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 非阻塞的等待 1 秒钟（默认时间单位是毫秒）</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 在延迟后打印输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 协程已在等待时主线程还在继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>结果中，协程延迟1秒后的输出没有了，因为任务结束了。不是说<code>runBlocking</code>会等待所有任务结束吗？<br>这里我们理一下逻辑，<strong><code>runBlocking</code>本质是在当前环境创建一个<code>域</code>，那么它的等待功能来源于<code>域</code>本身，而我们使用的是<code>GlobalScope</code>，这是一个全局<code>域</code>，尽管代码是在<code>runBlocking</code>的里面，但是真正的协程却是放在了全局<code>域</code>中。</strong><br>那么我们可以得到一个结论，我们代码不管写在哪里，本质上还是需要看任务是放到了哪个<code>域</code>中。<br>尽管看起来像是废话，但是需要注意的是，这样的结果就会引申出一些结论了：</p>
<ul>
<li><code>域</code>和我们的<code>List</code>没有本质区别，需要添加进去才会有效。</li>
<li>任务嵌套与关联时，需要注意<code>域</code>的关联与区别，否则可能发生逻辑错误但是又找不到原因。</li>
<li><code>域</code>的任务等待以及任务管理功能，仅针对明确添加到<code>域</code>中的任务，<code>域</code>的嵌套只有使用<code>coroutineScope</code>创建的<code>域</code>才会有效果，否则也会产生上面的效果。</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>那么我们继续尝试它的其他特性，这里我们跳过那些看起来差不多的用例。我们直接尝试抽取协程到方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> world = test()</span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$world</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>这里我们没有使用官网的案例了，可以看到，我们直接用<code>suspend</code>声明了一个方法，里面挂起了1000ms，然后<code>main</code>里面直接调用并且使用了返回值。<br>结果也符合我们的预期，那么发生了什么？</p>
<p>上面我们有说到，<code>suspend</code>会让调用者挂起，然后等待返回值，这里我们可以理解，它在逻辑上发生了阻塞，并且等待结果产生后，再恢复了逻辑。<br>就相当于，我们在<code>test</code>方法传入了一个回调函数，它的返回值传入了回调函数，而我们最后的<code>println</code>语句是写在回调函数中。</p>
<p>尽管如此，但是<code>挂起</code>这个词还是让人感觉很不安，因为到底是挂起了谁？又把谁停止了下来。</p>
<p>这里，我们再次回忆一下上面的概念，协程必须在<code>域</code>中执行，就算是当前线程，那么也必须以一个当前线程的<code>域</code>为起点，而<code>域</code>我们说了这是一个管理器而已，内部有<code>loop</code>，那么挂起的就是这个<code>域</code>了。<br>那么挂起的这个<code>域</code>，会影响到外部吗？或者说，会产生什么影响吗？<br>我们其实可以直接试试：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"on start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> world = test()</span><br><span class="line">        println(<span class="string">"Hello, <span class="variable">$world</span>, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"on end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on start, 1600587921039</span><br><span class="line">Hello, World!, 1600587922113</span><br><span class="line">on end, 1600587922115</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>我在打印时，带上了时间戳。并且<code>runBlocking</code>不再是整个<code>main</code>了。我们从打印结果就可以总结几个点：</p>
<ul>
<li><code>域</code>的内部循环，会阻塞所在线程（一般情况下）</li>
<li><code>挂起</code>指的是<code>域</code>内部的<code>loop</code>挂起当前任务，加入到循环末尾，等待结果或者等待结束（这一点是依据<code>JavaScript</code>语言特点推论）</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>上面那么多，其实我们似乎还是做不到最开始的猜想，那么我们再增加一点东西：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"on start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = async(Dispatchers.IO) &#123; getData() &#125;</span><br><span class="line">        <span class="keyword">val</span> world = async(Dispatchers.Default) &#123; parse(<span class="keyword">data</span>.await()) &#125;</span><br><span class="line">        println(<span class="string">"Hello, <span class="subst">$&#123;world.await()&#125;</span>, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"on end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"getData, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;\"value\":\"World!\"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(value: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"parse, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">val</span> json = JSONObject(value)</span><br><span class="line">    <span class="keyword">return</span> json.optString(<span class="string">"value"</span>)?:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on start, 1600589874877</span><br><span class="line">getData, 1600589875013</span><br><span class="line">parse, 1600589876030</span><br><span class="line">Hello, World!, 1600589877043</span><br><span class="line">on end, 1600589877043</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>可以看到，耗时仍然很多，但是，我们做了一开始的设想。<br>我们有一个获取数据的方法,它是一个耗时的操作<br>我们还有一个数据解析的方法，它也是一个耗时的操作<br>而我们的解析方法，需要获取数据方法的返回值<br>我们上面的操作就完成了这个过程。</p>
<p>但是在写的过程中，发现一个疑惑，<code>data.await()</code>到底应该放在哪里呢？<br>我想了很久，觉得还是应该放在<code>async</code>里面，因为这是一个阻塞当前协程的挂起方法，会等待返回值，如果我希望的是等待最终返回值，那么这个等待，应该是交给下一个处理方法来等待。尽管看起来总的耗时不变，但是语意和结果就变了，也许我发起<code>parse</code>的异步任务之后，还有其他任务呢？如果<code>data.await()</code>放在外面，那岂不是要全部后续方法都等着他？这不是我们希望的，所以最后还是放在了<code>async</code>里面。<br>我们可以写个demo验证一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"on start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = async(Dispatchers.IO) &#123; getData() &#125;</span><br><span class="line">        <span class="keyword">val</span> world = async(Dispatchers.Default) &#123; parse(<span class="keyword">data</span>.await()) &#125;</span><br><span class="line">        launch &#123; other() &#125;</span><br><span class="line">        println(<span class="string">"Hello, <span class="subst">$&#123;world.await()&#125;</span>, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"on end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"getData, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;\"value\":\"World!\"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(value: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"parse, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">val</span> json = JSONObject(value)</span><br><span class="line">    <span class="keyword">return</span> json.optString(<span class="string">"value"</span>)?:<span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">other</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"other start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">"other end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我又加了个异步任务，让我们看看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on start, 1600590487126</span><br><span class="line">getData, 1600590487219</span><br><span class="line">other start, 1600590487227</span><br><span class="line">other end, 1600590488232</span><br><span class="line">parse, 1600590488234</span><br><span class="line">Hello, World!, 1600590489248</span><br><span class="line">on end, 1600590489248</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>可以看到，需要等待的解析任务没有影响到另一个任务的执行。那么按照我们上面的分析，<code>data.await()</code>放到外面呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"on start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = async(Dispatchers.IO) &#123; getData() &#125;.await()</span><br><span class="line">        <span class="keyword">val</span> world = async(Dispatchers.Default) &#123; parse(<span class="keyword">data</span>) &#125;</span><br><span class="line">        launch &#123; other() &#125;</span><br><span class="line">        println(<span class="string">"Hello, <span class="subst">$&#123;world.await()&#125;</span>, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"on end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"getData, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;\"value\":\"World!\"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(value: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">"parse, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">val</span> json = JSONObject(value)</span><br><span class="line">    <span class="keyword">return</span> json.optString(<span class="string">"value"</span>)?:<span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">other</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"other start, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">"other end, <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，只改了一个<code>.await()</code>的位置，那么结果呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on start, 1600590621552</span><br><span class="line">getData, 1600590621642</span><br><span class="line">parse, 1600590622658</span><br><span class="line">other start, 1600590622660</span><br><span class="line">other end, 1600590623664</span><br><span class="line">Hello, World!, 1600590623673</span><br><span class="line">on end, 1600590623674</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>可以看到，结果符合预期，它影响了我们后续的任务。这个挂起，只是相对线程来说的，可以释放挂起时的线程资源。但是对于内部来说，就是阻塞了。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>以上就是协程基本使用和一些特性了，那么Android中怎么使用呢？<br>我们知道，Android中，我们不用也不能自己写main方法，同时有UI线程，这是不能阻塞的，那么用协程，是怎么样的呢？我们一起体验一下。</p>
<h4 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h4><p><code>AndroidX</code>的<code>LifecycleScope</code>其实已经提供了包装好的并且关联生命周期的协程方法，但是此时我们是为了探究协程本身，因此，这里只使用协程的核心库。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于协程必须要有容器，因此，我们准备一个与Activity关联的域，它的对应调度器是主线程</span></span><br><span class="line">    <span class="comment">// 表示这是一个基于主线程的域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activityScope = CoroutineScope(Dispatchers.Main)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        setSupportActionBar(toolbar)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发更新方法</span></span><br><span class="line">        update()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个耗时的数据加载方法，我们让它延时1秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">(arg: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello <span class="variable">$arg</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新的方法，这里我们需要完成异步数据加载以及UI的更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 用当前的域来启动一个协程</span></span><br><span class="line">        activityScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> arg = <span class="string">"Kotlin"</span></span><br><span class="line">            <span class="comment">// 切换到IO协程做数据加载，当前位置挂起</span></span><br><span class="line">            <span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                loadData(arg)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到数据后，为View更新数据</span></span><br><span class="line">            textView.text = result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        <span class="comment">// 清理协程任务</span></span><br><span class="line">        activityScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个demo的布局文件是一个TextView。显示效果是应用打开1秒后，界面的文本发生了变化。<br>然后我们在<code>onDestroy</code>中清理了协程任务。</p>
<p>一切看起来没什么问题，运行起来也没有什么问题。但是细心的小伙伴是不是发现了什么问题？<br>为什么前面的<code>main</code>里面用创建出来的<code>域</code>运行时，会阻塞<code>域</code>后面的输出，我们说了，<code>域</code>里面是有<code>loop</code>的，会阻塞线程的，但是这里为什么没有？甚至时间加长到10秒，都没有发生<code>ANR</code>呢？</p>
<p>这里我们似乎弄混了一件事情，前面的阻塞，是<code>runBlocking</code>方式创建的<code>域</code>，而且是这个<code>域</code>本身阻塞了。而我们这里，虽然也创建了一个<code>域</code>，但是这个<code>域</code>只是在主线程，并不代表它整个运行在主线程。可以理解为，它是一个<code>Handler</code>，挂起时是不占用线程的。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>上面还是一个非常基础的Demo，但是，我也不打算继续举例了，因为协程的案例非常多，官方或者第三方实现的集成库也非常多。弄明白了基本的逻辑及特性之后，只剩下了个人的喜好选择而已。因此，再写下去也没有了必要。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener">Kotlin·协程指南</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">Android·将Kotlin协程与架构组件一起使用</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">Android·Kotlin协程</a></li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='83769e11ad8dee614a88'
        data-cs='3de1ef474db139cd0f47e8769f5afed5db7da651'
        data-r='blogTalk'
        data-o='lollipoppp'
        data-a='lollipoppp'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本组成"><span class="toc-number">1.2.</span> <span class="toc-text">基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CoroutineScope"><span class="toc-number">1.2.1.</span> <span class="toc-text">CoroutineScope</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Job"><span class="toc-number">1.2.2.</span> <span class="toc-text">Job</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CoroutineContext"><span class="toc-number">1.2.3.</span> <span class="toc-text">CoroutineContext</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CoroutineDispatcher"><span class="toc-number">1.2.4.</span> <span class="toc-text">CoroutineDispatcher</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#结构"><span class="toc-number">1.2.5.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法"><span class="toc-number">1.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#launch"><span class="toc-number">1.3.1.</span> <span class="toc-text">launch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#async"><span class="toc-number">1.3.2.</span> <span class="toc-text">async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#runBlocking"><span class="toc-number">1.3.3.</span> <span class="toc-text">runBlocking</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delay"><span class="toc-number">1.3.4.</span> <span class="toc-text">delay</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#coroutineScope"><span class="toc-number">1.3.5.</span> <span class="toc-text">coroutineScope</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#withContext"><span class="toc-number">1.3.6.</span> <span class="toc-text">withContext</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield"><span class="toc-number">1.3.7.</span> <span class="toc-text">yield</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#suspend"><span class="toc-number">1.3.8.</span> <span class="toc-text">suspend</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开始"><span class="toc-number">2.1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法-1"><span class="toc-number">2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步"><span class="toc-number">2.3.</span> <span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">3.</span> <span class="toc-text">Android</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开始-1"><span class="toc-number">3.1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结束"><span class="toc-number">3.2.</span> <span class="toc-text">结束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后记"><span class="toc-number">4.</span> <span class="toc-text">后记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文档"><span class="toc-number">4.1.</span> <span class="toc-text">参考文档</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-153109857-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
