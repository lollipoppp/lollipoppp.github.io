
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>地图路线叠加层实现方案 - Lollipop</title>
    <meta name="baidu-site-verification" content="lGVNqFPfNO" />
    <meta name="google-site-verification" content="sm3JfidSJFBpLMJ5iPEwXzBiGID7DzfiKlJaktGdgIo" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Lollipop,"> 
    <meta name="description" content="A simple blog site,因为工作业务需要，需要在地图上显示点之间的连线，并且由点击事件，这个线路不是路线规划，也不是直线，还需要有点击事件的容错。因此寻思着自己写一个。

温馨提示: 本篇内容演示代码均为 Kotlin 语,"> 
    <meta name="author" content="Lollipop"> 
    <link rel="alternative" href="atom.xml" title="Lollipop" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">Lollipop</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://lollipoppp.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">地图路线叠加层实现方案</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">地图路线叠加层实现方案</h1>
        <div class="stuff">
            <span>六月 28, 2018</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E2%80%9CAndroid%E2%80%9D/" rel="tag">“Android”</a></li></ul>


        </div>
        <div class="content markdown">
            <p>因为工作业务需要，需要在地图上显示点之间的连线，并且由点击事件，这个线路不是路线规划，也不是直线，还需要有点击事件的容错。因此寻思着自己写一个。</p>
<blockquote>
<p>温馨提示: 本篇内容演示代码均为 <strong>Kotlin</strong> 语言。如果你是使用 <strong>Java</strong>，那么部分方法或者关键字需要稍微做一下转换，但是本身算法和代码是通用的。</p>
</blockquote>
<p>首先送上效果图<br><img src="../../../../images/1574262726690.png" alt="效果图"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>拥有经纬度，那么想办法转化为屏幕坐标。</li>
<li>将一组组的屏幕坐标整理出来，先设计一组坐标的绘制方案。</li>
<li>绘制两点之间的曲线。</li>
<li>计算曲线的路径，得到点击事件。</li>
</ol>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><h3 id="计算屏幕坐标"><a href="#计算屏幕坐标" class="headerlink" title="计算屏幕坐标"></a>计算屏幕坐标</h3><p>高德有提供一个工具方法，可以将经纬度转换为当前地图上的屏幕坐标。所以这个可以一行代码搞定。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得投影对象</span></span><br><span class="line"><span class="keyword">val</span> projection = aMap.projection</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">val</span> startPoint = projection.toScreenLocation(bean.startLoc)</span><br><span class="line"><span class="keyword">val</span> endPoint = projection.toScreenLocation(bean.endLoc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法</span></span><br><span class="line">projection.toScreenLocation(LatLng)</span><br></pre></td></tr></table></figure>

<h3 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h3><p>我们的线路中有起点和终点，两点之间的连线要弯曲成一定的弧度。<br>那么既然要绘制曲线，可以有几种方案：<br>  1. 绘制一段弧线，Canvas.drawArc()。<br>  2. 贝塞尔曲线连接。<br>但是弧线的话，需要计算圆心位置，半径信息。而这些就比较复杂了。因为一段任意的有方向的线段，要计算他的所在圆的圆心，并不容易。因此放弃了这个方法。<br>剩下的就是贝塞尔曲线了，我们可以考虑将辅助点从<strong>两点的中点</strong>往与<strong>线段平行</strong>的方向移动一点距离，从而得到一条弧线。</p>
<p>思路已经有了，那么下一步呢？怎么计算这个辅助点呢？<br>首先，按照上面的思路，总结出关键字：<strong>中点，平行</strong>。<br>也就是说，我们要在线段的<strong>中点</strong>位置做<strong>垂线</strong>，又是三角函数了。我就在想，有没有更加简单的方法？</p>
<p>方法也其实简单，我们在纸上怎么为线段画垂线的呢？三角板靠上去？如果不顺手怎么办？答案出来了，我们可以把纸张转一下啊。<br>那么我们是不是可以也借助这种思想呢？事实是可以的。<br>那么我们的算法就简单了，假设我们已经将画布旋转了，把线段与坐标系的X轴重叠，并且把起点放到了坐标系的起点位置，那么我们的线段就相当于X轴了，而给X轴做垂线？X不变，Y加上一段距离就好了，对吧。<br>那么，既然这样的话。<br>我们再整理一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">辅助点X = 线段长度 / <span class="number">2</span></span><br><span class="line">辅助点Y = 线段长度 * 弧度权重</span><br><span class="line"><span class="comment">//这里的弧度权重是我个人定义的，因为个人认为，根据长度*权重，可以使辅助点的位置跟随长度变大而变大，使人看起来弧度是一样的。</span></span><br></pre></td></tr></table></figure>

<p>好了，上面就是我们的算法。那么问题来了，根据上面的算法，我们又需要另外2个东西了，一个是旋转角度，一个是线段长度。<br>线段长度的算法很简单：就是简单的勾股定理而已。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLineLength</span><span class="params">(startPointF: <span class="type">PointF</span>, endPointF: <span class="type">PointF</span>)</span></span>: <span class="built_in">Float</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(<span class="number">1.0</span> * (startPointF.x - endPointF.x)*(startPointF.x - endPointF.x)</span><br><span class="line">            + (startPointF.y - endPointF.y)*(startPointF.y - endPointF.y)).toFloat()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们的角度算法就稍微繁琐一点了，因为涉及到三角函数和坐标系问题，因为屏幕的坐标系和手机坐标系是不一样的，屏幕上，左上角是起点，然后向下是Y的正轴，所以有些颠倒。不过也还好吧。因为算法也就那样，所以直接贴上角度代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAngle</span><span class="params">(start: <span class="type">PointF</span>, end: <span class="type">PointF</span>)</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = (end.y - start.y) * <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">val</span> b = (end.x - start.x) * <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">val</span> angle = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">when</span>&#123;</span><br><span class="line"></span><br><span class="line">            a &gt; <span class="number">0</span> &amp;&amp; b &gt;= <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                <span class="number">360</span>-Math.toDegrees(Math.atan(a / b))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                Math.toDegrees(Math.atan(a / -b)) - <span class="number">180</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a &lt;= <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                Math.toDegrees(Math.atan(-a / b))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                <span class="number">180</span> - Math.toDegrees(Math.atan(-a / -b))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (e: Exception)&#123;</span><br><span class="line">        <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angle</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本人能力有限，没有整理出一套通用的算法，所以我就只有四个象限分别计算了。</p>
<p>以上，2个主要参数都出来了，那么绘制呢？我们用Path来做绘制。也就是说，我们在Path里面拉出贝塞尔曲线，再Canvas.drawPath()。<br>而这里，我们使用三次贝塞尔来绘制，因为二次贝塞尔曲线不是很好看。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPointChange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//重置路径</span></span><br><span class="line">    path.reset()</span><br><span class="line">    <span class="comment">//设置路径起点</span></span><br><span class="line">    path.moveTo(<span class="number">0F</span>,<span class="number">0F</span>)</span><br><span class="line">    <span class="comment">//获取当前路径长度</span></span><br><span class="line">    pointSpacing = getLineLength(startPoint,endPoint)</span><br><span class="line">    <span class="comment">//用贝塞尔曲线向下弯曲一定程度并且连接至终点</span></span><br><span class="line">    path.cubicTo(pointSpacing/<span class="number">3</span>,pointSpacing*-<span class="number">0.1F</span>,pointSpacing * <span class="number">2</span> / <span class="number">3</span>,pointSpacing*-<span class="number">0.1F</span>,pointSpacing,<span class="number">0F</span>)</span><br><span class="line"></span><br><span class="line">    saveClickPoint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说明一下path.cubicTo()函数，他有6个参数，分为3组，按照我的理解是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	（上一个点的辅助点X，上一个点的辅助点Y），</span><br><span class="line">	（下一个点的辅助点X，下一个点的辅助点Y），</span><br><span class="line">	（下一个点的X，下一个点的Y）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的算法可以看出来，我是将线段分为3份，分别在中间的2个节点插辅助点，辅助点的高度一样，都是长度的十分之一。这样的效果是不至于曲线峰顶不至于太过尖锐，让整个曲线比较平缓。而路径起点设置为(0,0)的原因是，前面说了，假设起点为坐标系原点。</p>
<p>路径已经设置好了，那么我们只要绘制就好了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(canvas == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//保存画布状态</span></span><br><span class="line">       canvas.save()</span><br><span class="line">       <span class="comment">//移动画笔起点为线路起点位置</span></span><br><span class="line">      	canvas.translate(arrow.startPoint.x,arrow.startPoint.y)</span><br><span class="line">       <span class="comment">//旋转画布，使线路重叠与X轴</span></span><br><span class="line">       canvas.rotate(-<span class="number">1</span>*arrow.getAngle().toFloat())</span><br><span class="line">       <span class="comment">//绘制路径</span></span><br><span class="line">       canvas.drawPath(arrow.path,paint)</span><br><span class="line">	<span class="comment">//恢复到上次保存的画布状态</span></span><br><span class="line">       canvas.restore()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这样就行了，代码里面的arrow是我将前面的算法封装到Bean里面了，绘制的时候只需要拿数据就好了，因为后续会有很多线段，如果全部都在绘制的时候，计算，那么会相当卡顿，如果我放到Bean里面，那么将绘制和计算分离开，那么就可以加快绘制的速度了。</p>
<p>前面绘制已经完了，理想的情况下，是可以绘制出一条曲线的了。但是截图里面，还有个箭头，本来是有2个箭头的，将曲线三等分，但是考虑UI复杂度，所以变成了一个箭头，但是代码实现是支持多箭头的。</p>
<p>箭头的数量，其实并不重要，不过是一个循环而已，重点是，箭头的方向要和曲线相同，也就是说，需要知道曲线的切线。</p>
<p>很幸运的是，Google为我们提供了方法（我将算法和iOS小伙伴交流的时候发现，他们没有，窃喜）。方法也是比较简单的，PathMeasure类，路径的测量类。</p>
<p>使用方法也是非常简单的，只需要将Path关联到PathMeasure类上即可，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathMeasure.setPath(path, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>参数有2个，第一个是路径，第二个boolean值是说，是否在计算的时候，将路径视为闭合的，也就是说，算的时候，当做path已经closed，但是不会影响path本身。很贴心的功能，但是我们不需要。</p>
<p>那么怎么用呢？<br>我们需要用到的只有这个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> position = FloatArray(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> tangent = FloatArray(<span class="number">2</span>)</span><br><span class="line">pathMeasure.getPosTan(length,position,tangent)</span><br></pre></td></tr></table></figure>

<p><strong>getPosTan</strong>方法的功能是：传入指定长度，然后将指定长度位置的坐标和对应的切线<br>position为传出的坐标位置。<br>tangent为传出的切线角度。<br>你可能会问了，曲线的长度呢？前面都是直线长度啊？<br>这里提一下，pathMeasure提供了获取路径长度的方法，叫做</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathMeasure.length</span><br></pre></td></tr></table></figure>

<p>这样就够了，我们就可以使用了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawArrow</span><span class="params">(canvas: <span class="type">Canvas</span>,arrow: <span class="type">Arrow</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//保存画布状态</span></span><br><span class="line">      canvas.save()</span><br><span class="line"><span class="comment">//将画笔的颜色设置为线条需要的颜色</span></span><br><span class="line">      paint.color = arrow.color</span><br><span class="line"><span class="comment">//为画笔设置线条宽度，lineWidth是一个固定值，这里是作为成员变量方便统一修改</span></span><br><span class="line">      paint.strokeWidth = lineWidth</span><br><span class="line"><span class="comment">//每个线条维护一个路径测量类，之所以独立起来，是为了方便扩展（尽管还没想到扩展什么）</span></span><br><span class="line"><span class="comment">//将路径与测量器关联起来</span></span><br><span class="line">      arrow.pathMeasure.setPath(arrow.path,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//点坐标</span></span><br><span class="line">      <span class="keyword">val</span> position = FloatArray(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//点切线</span></span><br><span class="line">      <span class="keyword">val</span> tangent = FloatArray(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//拿到弧线中间点的位置和切线（如果是2个，那么可以拿⅓和⅔长度的位置和切线，以此类推）</span></span><br><span class="line">      arrow.pathMeasure.getPosTan(arrow.pathMeasure.length / <span class="number">2</span>,position,tangent)</span><br><span class="line"><span class="comment">//将切线数据转化为角度，不要问我为啥，我也是搜索出来直接用的</span></span><br><span class="line">      <span class="keyword">val</span> degrees = (Math.atan2(tangent[<span class="number">1</span>].toDouble(), tangent[<span class="number">0</span>].toDouble()) * <span class="number">180.0</span> / Math.PI).toFloat()</span><br><span class="line"><span class="comment">//将画布坐标移动到箭头的起点，方便绘制</span></span><br><span class="line">      canvas.translate(position[<span class="number">0</span>],position[<span class="number">1</span>])</span><br><span class="line"><span class="comment">//旋转切线角度</span></span><br><span class="line">      canvas.rotate(degrees)</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制线条上方的那一边箭头</span></span><br><span class="line">      canvas.drawLine(<span class="number">0F</span>,<span class="number">0F</span>,-arrowSize,-arrowSize,paint)</span><br><span class="line"><span class="comment">//绘制线条下方的那一边箭头（与上一行对比，可以看出只有Y变了，一个在上，一个在下，对称）</span></span><br><span class="line">      canvas.drawLine(<span class="number">0F</span>,<span class="number">0F</span>,-arrowSize,arrowSize,paint)</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复画板坐标系状态为上一次储存的状态（你可以理解为Ctrl+Z，存和退是一组组对应的，就像括号）</span></span><br><span class="line">      canvas.restore()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>OK，绘制基本上就全部完成了，我贴一个完整的绘制方法出来，包含了起点和终点的小圆点，多条线段绘制等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">//画布为空则放弃绘制</span></span><br><span class="line">      <span class="keyword">if</span>(canvas == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//对线路集合进行循环</span></span><br><span class="line">      <span class="keyword">for</span>(arrow <span class="keyword">in</span> arrowList)&#123;</span><br><span class="line">	<span class="comment">//设置画笔颜色</span></span><br><span class="line">          paint.color = arrow.color</span><br><span class="line">	<span class="comment">//设置画笔宽度</span></span><br><span class="line">          paint.strokeWidth = lineWidth</span><br><span class="line">	<span class="comment">//设置为描边模式，设置为填充模式的话，就变色半圆色块了</span></span><br><span class="line">          paint.style = Paint.Style.STROKE</span><br><span class="line"></span><br><span class="line">          <span class="comment">//保存画布状态</span></span><br><span class="line">          canvas.save()</span><br><span class="line">          <span class="comment">//移动画笔起点为线路起点位置</span></span><br><span class="line">          canvas.translate(arrow.startPoint.x,arrow.startPoint.y)</span><br><span class="line">          <span class="comment">//旋转画布，使线路重叠与X轴</span></span><br><span class="line">          canvas.rotate(-<span class="number">1</span>*arrow.getAngle().toFloat())</span><br><span class="line">          <span class="comment">//绘制路径</span></span><br><span class="line">          canvas.drawPath(arrow.path,paint)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绘制线路上的箭头</span></span><br><span class="line">          drawArrow(canvas,arrow)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置模式为填充和描边</span></span><br><span class="line">          paint.style = Paint.Style.FILL_AND_STROKE</span><br><span class="line">	<span class="comment">//描边宽度设置为1</span></span><br><span class="line">          paint.strokeWidth = <span class="number">1F</span></span><br><span class="line">          <span class="comment">//绘制点，设置颜色为边框颜色</span></span><br><span class="line">          paint.color = pointStrokeColor</span><br><span class="line">	<span class="comment">//绘制起点的边框（因为不方便设置圆形包边，因此绘制2次）</span></span><br><span class="line">          canvas.drawCircle(<span class="number">0F</span>,<span class="number">0F</span>,pointR+pointStroke,paint)</span><br><span class="line">	<span class="comment">//绘制终点的边框</span></span><br><span class="line">          canvas.drawCircle(arrow.pointSpacing,<span class="number">0F</span>,pointR+pointStroke,paint)</span><br><span class="line">	<span class="comment">//设置颜色为内圆颜色</span></span><br><span class="line">          paint.color = pointColor</span><br><span class="line">	<span class="comment">//绘制起点内圆</span></span><br><span class="line">          canvas.drawCircle(<span class="number">0F</span>,<span class="number">0F</span>,pointR,paint)</span><br><span class="line">	<span class="comment">//绘制终点内圆</span></span><br><span class="line">          canvas.drawCircle(arrow.pointSpacing,<span class="number">0F</span>,pointR,paint)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//恢复到上次保存的画布状态</span></span><br><span class="line">          canvas.restore()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>OK，我们的绘制就都做完了，至于你说刷新？你自己去监听地图拖拽和缩放，然后刷新点坐标数据啊，然后发起重绘啊。</p>
<p>这部分不属于本次内容范畴，所以查查地图API吧。</p>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p>接下来是最后一步了，线路的点击，计算怎么点击到线路上？</p>
<p>我们来理一下，我们真实的需求吧，我真正的需求是，怎么才能判断点击的位置是否在曲线上，或者曲线范围内。</p>
<p>既然是这样的话，怎么做呢？方案很多，我这里的方案是打关键点。<br>就是说，我在弧线上打多个关键点，每个点为圆心做一个圆，如果点击位置在园内，那么圆所在的线路，就认为被点击了。</p>
<p>是不是感觉似曾相识？没错，又要用到前面的路径测量器了。</p>
<p>这个就很简单了，只是像上面绘制箭头一样，拿到坐标就好了。但是，又是但是。<br>我前面说了，我们前面的算法都是基于旋转和位移，也就说，所有的坐标都是相对的，而我们的点击位置都是绝对坐标。所以我们还要研究一下反向算法。</p>
<p>怎么矫正呢？</p>
<p>首先是角度，我们把点的角度倒过来转就好了，这里不能使用canvas的rotate()了，我们要计算计算，而这个算法说到底，就是B点绕A点旋转而已。对吧，所以这个算法，我是这样写的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">route</span><span class="params">(p: <span class="type">PointF</span>, center: <span class="type">PointF</span>, angle: <span class="type">Double</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//当前待处理点的X坐标</span></span><br><span class="line">      <span class="keyword">val</span> x1 = p.x</span><br><span class="line"><span class="comment">//当前待处理点的Y坐标</span></span><br><span class="line">      <span class="keyword">val</span> y1 = p.y</span><br><span class="line"><span class="comment">//旋转中心的X坐标</span></span><br><span class="line">      <span class="keyword">val</span> x2 = center.x</span><br><span class="line"><span class="comment">//旋转中心的Y坐标</span></span><br><span class="line">      <span class="keyword">val</span> y2 = center.y</span><br><span class="line"><span class="comment">//将旋转角度计算为弧度</span></span><br><span class="line">      <span class="keyword">val</span> radians = Math.toRadians(angle)</span><br><span class="line"><span class="comment">//下面这段代码是抄过来的，懒得解释了，数学问题什么的最烦了。</span></span><br><span class="line"><span class="comment">//反正就是一个点绕另一个点绕一定角度后的位置</span></span><br><span class="line">      p.x = ((x1 - x2) * Math.cos(radians) + (y1 - y2) * Math.sin(radians) + x2).toFloat()</span><br><span class="line">      p.y = (-(x1 - x2) * Math.sin(radians) + (y1 - y2) * Math.cos(radians) + y2).toFloat()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>嗯，完成上面的算法，那么就把坐标换算的问题都解决了，接下来就是记录关键点：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveClickPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//储存位置用的数组</span></span><br><span class="line">      <span class="keyword">val</span> position = FloatArray(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//存储切线用的数组，此处没有用，只是为了避免空指针</span></span><br><span class="line">      <span class="keyword">val</span> tangent = FloatArray(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//关联路径测量器和路径</span></span><br><span class="line">      pathMeasure.setPath(path,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//检查当前关键点的数量是否增加</span></span><br><span class="line">      <span class="keyword">while</span> (clickPointList.size &lt; clickPointSize)&#123;</span><br><span class="line">          clickPointList.add(PointF())</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//检查当前关键点的数量是否有多余</span></span><br><span class="line">      <span class="keyword">while</span> (clickPointList.size &gt; clickPointSize)&#123;</span><br><span class="line">          clickPointList.removeAt(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//记录当前关键点密度的情况下，间隔长度</span></span><br><span class="line">      <span class="keyword">val</span> step = pathMeasure.length / clickPointList.size</span><br><span class="line"><span class="comment">//循环为每个点做数据赋值</span></span><br><span class="line">      <span class="keyword">for</span>(index <span class="keyword">in</span> <span class="number">0</span> until clickPointList.size)&#123;</span><br><span class="line">	<span class="comment">//测量当前点的位置信息</span></span><br><span class="line">          pathMeasure.getPosTan(step * index ,position,tangent)</span><br><span class="line">	<span class="comment">//对当前点进行赋值，并且将起点的坐标加上去，变为真实位置</span></span><br><span class="line">          clickPointList[index].<span class="keyword">set</span>(position[<span class="number">0</span>]+startPoint.x,position[<span class="number">1</span>]+startPoint.y)</span><br><span class="line">	<span class="comment">//旋转点角度，纠正角度</span></span><br><span class="line">          route(clickPointList[index],startPoint,getAngle())</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如此就算是完了。对了，你会说，那么怎么用？很简单啊，for循环就好了啊。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断点击位置是否在圆内</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkPoint</span><span class="params">(point: <span class="type">PointF</span>,x: <span class="type">Int</span>,y: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">	<span class="comment">//通过勾股定理，计算点击点位置和圆心的距离是否小于半径长度</span></span><br><span class="line">       <span class="keyword">val</span> length = Math.sqrt(<span class="number">1.0</span> * (point.x - x)*(point.x - x)</span><br><span class="line">               + (point.y - y)*(point.y - y)).toFloat()</span><br><span class="line">       <span class="keyword">return</span> length &lt;= clickRadius</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//检查是否在某个点的范围内</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">checkOnClick</span><span class="params">(x: <span class="type">Int</span>,y: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//开启一个线程，因为太多的数据，可能带来耗时</span></span><br><span class="line">	<span class="comment">//本人也没有太好的算法</span></span><br><span class="line">       TaskUtils.<span class="keyword">get</span>().runAs &#123;</span><br><span class="line">		<span class="comment">//获取全部的线路，并且遍历</span></span><br><span class="line">           <span class="keyword">for</span> (arrow <span class="keyword">in</span> lineDrawable.arrowList)&#123;</span><br><span class="line">			<span class="comment">//获取线路下全部的点，进行遍历</span></span><br><span class="line">               <span class="keyword">for</span>(point <span class="keyword">in</span> arrow.clickPointList)&#123;</span><br><span class="line">				<span class="comment">//检查是否点击中</span></span><br><span class="line">                   <span class="keyword">if</span>(checkPoint(point,x, y))&#123;</span><br><span class="line">					<span class="comment">//当判定为点中时，发送回调并且终止循环</span></span><br><span class="line">                       post &#123;</span><br><span class="line">                           onMapLineClick(arrow)</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">return</span><span class="symbol">@runAs</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//如果循环结束仍然没有点击中的点，那么发送没有点中的回调</span></span><br><span class="line">           post &#123;</span><br><span class="line">               onNoMapLineClick()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>至此，所有的逻辑都讲完了。最后再贴上完整的代码。</p>
<h2 id="全部源码"><a href="#全部源码" class="headerlink" title="全部源码"></a>全部源码</h2><p>线路的Bean</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.graphics.*</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地图线条的Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lollipop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arrow</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startPoint = PointF()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> endPoint = PointF()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> color = Color.BLACK</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> path = Path()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointSpacing = <span class="number">0F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> clickPointList = ArrayList&lt;PointF&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clickPointSize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> viewHeight = <span class="number">0F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pathMeasure = PathMeasure()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPointChange</span><span class="params">(start: <span class="type">Point</span>, end: <span class="type">Point</span>)</span></span>&#123;</span><br><span class="line">        startPoint.<span class="keyword">set</span>(start.x.toFloat(),start.y.toFloat())</span><br><span class="line">        endPoint.<span class="keyword">set</span>(end.x.toFloat(),end.y.toFloat())</span><br><span class="line">        onPointChange()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPointChange</span><span class="params">(startX: <span class="type">Float</span>,startY: <span class="type">Float</span>, endX: <span class="type">Float</span>, endY: <span class="type">Float</span>)</span></span>&#123;</span><br><span class="line">        startPoint.<span class="keyword">set</span>(startX,startY)</span><br><span class="line">        endPoint.<span class="keyword">set</span>(endX,endY)</span><br><span class="line">        onPointChange()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPointChange</span><span class="params">(start: <span class="type">PointF</span>, end: <span class="type">PointF</span>)</span></span>&#123;</span><br><span class="line">        startPoint.<span class="keyword">set</span>(start)</span><br><span class="line">        endPoint.<span class="keyword">set</span>(end)</span><br><span class="line">        onPointChange()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPointChange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//重置路径</span></span><br><span class="line">        path.reset()</span><br><span class="line">        <span class="comment">//设置路径起点</span></span><br><span class="line">        path.moveTo(<span class="number">0F</span>,<span class="number">0F</span>)</span><br><span class="line">        <span class="comment">//获取当前路径长度</span></span><br><span class="line">        pointSpacing = getLineLength(startPoint,endPoint)</span><br><span class="line">        <span class="comment">//用贝塞尔曲线向下弯曲一定程度并且连接至终点</span></span><br><span class="line">        path.cubicTo(pointSpacing/<span class="number">3</span>,pointSpacing*-<span class="number">0.1F</span>,pointSpacing * <span class="number">2</span> / <span class="number">3</span>,pointSpacing*-<span class="number">0.1F</span>,pointSpacing,<span class="number">0F</span>)</span><br><span class="line"></span><br><span class="line">        saveClickPoint()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLineLength</span><span class="params">(startPointF: <span class="type">PointF</span>, endPointF: <span class="type">PointF</span>)</span></span>: <span class="built_in">Float</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(<span class="number">1.0</span> * (startPointF.x - endPointF.x)*(startPointF.x - endPointF.x)</span><br><span class="line">                + (startPointF.y - endPointF.y)*(startPointF.y - endPointF.y)).toFloat()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveClickPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> position = FloatArray(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> tangent = FloatArray(<span class="number">2</span>)</span><br><span class="line">        pathMeasure.setPath(path,<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">while</span> (clickPointList.size &lt; clickPointSize)&#123;</span><br><span class="line">            clickPointList.add(PointF())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (clickPointList.size &gt; clickPointSize)&#123;</span><br><span class="line">            clickPointList.removeAt(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> step = pathMeasure.length / clickPointList.size</span><br><span class="line">        <span class="keyword">for</span>(index <span class="keyword">in</span> <span class="number">0</span> until clickPointList.size)&#123;</span><br><span class="line">            pathMeasure.getPosTan(step * index ,position,tangent)</span><br><span class="line">            clickPointList[index].<span class="keyword">set</span>(position[<span class="number">0</span>]+startPoint.x,position[<span class="number">1</span>]+startPoint.y)</span><br><span class="line">            route(clickPointList[index],startPoint,getAngle())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAngle</span><span class="params">()</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAngle(startPoint,endPoint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAngle</span><span class="params">(start: <span class="type">PointF</span>, end: <span class="type">PointF</span>)</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> a = (end.y - start.y) * <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">val</span> b = (end.x - start.x) * <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">val</span> angle = <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">when</span>&#123;</span><br><span class="line"></span><br><span class="line">                a &gt; <span class="number">0</span> &amp;&amp; b &gt;= <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                    <span class="number">360</span>-Math.toDegrees(Math.atan(a / b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                    Math.toDegrees(Math.atan(a / -b)) - <span class="number">180</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                a &lt;= <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                    Math.toDegrees(Math.atan(-a / b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;<span class="comment">//√</span></span><br><span class="line">                    <span class="number">180</span> - Math.toDegrees(Math.atan(-a / -b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (e: Exception)&#123;</span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> angle</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">route</span><span class="params">(p: <span class="type">PointF</span>, center: <span class="type">PointF</span>, angle: <span class="type">Double</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> x1 = p.x</span><br><span class="line">        <span class="keyword">val</span> y1 = p.y</span><br><span class="line">        <span class="keyword">val</span> x2 = center.x</span><br><span class="line">        <span class="keyword">val</span> y2 = center.y</span><br><span class="line">        <span class="keyword">val</span> radians = Math.toRadians(angle)</span><br><span class="line">        p.x = ((x1 - x2) * Math.cos(radians) + (y1 - y2) * Math.sin(radians) + x2).toFloat()</span><br><span class="line">        p.y = (-(x1 - x2) * Math.sin(radians) + (y1 - y2) * Math.cos(radians) + y2).toFloat()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绘制线路的Drawable</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.graphics.*</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地图线条的Drawable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lollipop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapLineDrawable</span>: <span class="type">Drawable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint().apply &#123;</span><br><span class="line">        style = Paint.Style.STROKE</span><br><span class="line">        isAntiAlias = <span class="literal">true</span></span><br><span class="line">        isDither = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> arrowList = ArrayList&lt;Arrow&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lineWidth = <span class="number">5F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointR = <span class="number">5F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointStroke = <span class="number">2F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointStrokeColor = Color.WHITE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointColor = Color.CYAN</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arrowSize = <span class="number">2F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clickRadius = <span class="number">2F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(canvas == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(arrow <span class="keyword">in</span> arrowList)&#123;</span><br><span class="line">            paint.color = arrow.color</span><br><span class="line">            paint.strokeWidth = lineWidth</span><br><span class="line">            paint.style = Paint.Style.STROKE</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存画布状态</span></span><br><span class="line">            canvas.save()</span><br><span class="line">            <span class="comment">//移动画笔起点为线路起点位置</span></span><br><span class="line">            canvas.translate(arrow.startPoint.x,arrow.startPoint.y)</span><br><span class="line">            <span class="comment">//旋转画布，使线路重叠与X轴</span></span><br><span class="line">            canvas.rotate(-<span class="number">1</span>*arrow.getAngle().toFloat())</span><br><span class="line">            <span class="comment">//绘制路径</span></span><br><span class="line">            canvas.drawPath(arrow.path,paint)</span><br><span class="line"></span><br><span class="line">            drawArrow(canvas,arrow)</span><br><span class="line"></span><br><span class="line">            paint.style = Paint.Style.FILL_AND_STROKE</span><br><span class="line">            paint.strokeWidth = <span class="number">1F</span></span><br><span class="line">            <span class="comment">//绘制点</span></span><br><span class="line">            paint.color = pointStrokeColor</span><br><span class="line">            canvas.drawCircle(<span class="number">0F</span>,<span class="number">0F</span>,pointR+pointStroke,paint)</span><br><span class="line">            canvas.drawCircle(arrow.pointSpacing,<span class="number">0F</span>,pointR+pointStroke,paint)</span><br><span class="line">            paint.color = pointColor</span><br><span class="line">            canvas.drawCircle(<span class="number">0F</span>,<span class="number">0F</span>,pointR,paint)</span><br><span class="line">            canvas.drawCircle(arrow.pointSpacing,<span class="number">0F</span>,pointR,paint)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复到上次保存的画布状态</span></span><br><span class="line">            canvas.restore()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawArrow</span><span class="params">(canvas: <span class="type">Canvas</span>,arrow: <span class="type">Arrow</span>)</span></span>&#123;</span><br><span class="line">        canvas.save()</span><br><span class="line">        paint.color = arrow.color</span><br><span class="line">        paint.strokeWidth = lineWidth</span><br><span class="line">        arrow.pathMeasure.setPath(arrow.path,<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> position = FloatArray(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> tangent = FloatArray(<span class="number">2</span>)</span><br><span class="line">        arrow.pathMeasure.getPosTan(arrow.pathMeasure.length / <span class="number">2</span>,position,tangent)</span><br><span class="line">        <span class="keyword">val</span> degrees = (Math.atan2(tangent[<span class="number">1</span>].toDouble(), tangent[<span class="number">0</span>].toDouble()) * <span class="number">180.0</span> / Math.PI).toFloat()</span><br><span class="line">        canvas.translate(position[<span class="number">0</span>],position[<span class="number">1</span>])</span><br><span class="line">        canvas.rotate(degrees)</span><br><span class="line"></span><br><span class="line">        canvas.drawLine(<span class="number">0F</span>,<span class="number">0F</span>,-arrowSize,-arrowSize,paint)</span><br><span class="line">        canvas.drawLine(<span class="number">0F</span>,<span class="number">0F</span>,-arrowSize,arrowSize,paint)</span><br><span class="line"></span><br><span class="line">        canvas.restore()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setAlpha</span><span class="params">(alpha: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        paint.alpha = alpha</span><br><span class="line">        invalidateSelf()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOpacity</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PixelFormat.TRANSPARENT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setColorFilter</span><span class="params">(colorFilter: <span class="type">ColorFilter</span>?)</span></span> &#123;</span><br><span class="line">        paint.colorFilter = colorFilter</span><br><span class="line">        invalidateSelf()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绘制线路的View</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color</span><br><span class="line"><span class="keyword">import</span> android.graphics.Point</span><br><span class="line"><span class="keyword">import</span> android.graphics.PointF</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.collections.ArrayList</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地图线路的绘制View</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lollipop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapLineView</span></span>(context: Context, attrs: AttributeSet?, defStyleAttr:<span class="built_in">Int</span>): ImageView(context, attrs, defStyleAttr),</span><br><span class="line">        OnMapLineClickListener  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?):<span class="keyword">this</span>(context,attrs,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context):<span class="keyword">this</span>(context,<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> recyclingList = LinkedList&lt;Arrow&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lineDrawable = MapLineDrawable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> onMapLineClickListenerList = ArrayList&lt;OnMapLineClickListener&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> clickRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">20F</span>,context.resources.displayMetrics)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        background = lineDrawable</span><br><span class="line">        lineDrawable.lineWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">2F</span>,context.resources.displayMetrics)</span><br><span class="line">        lineDrawable.pointR = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">3F</span>,context.resources.displayMetrics)</span><br><span class="line">        lineDrawable.pointStroke = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">1F</span>,context.resources.displayMetrics)</span><br><span class="line">        lineDrawable.pointStrokeColor = Color.WHITE</span><br><span class="line">        lineDrawable.arrowSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">3F</span>,context.resources.displayMetrics)</span><br><span class="line">        lineDrawable.clickRadius = clickRadius</span><br><span class="line">        lineDrawable.pointColor = <span class="number">0xFFFFAB3A</span>.toInt()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        recyclingList.addAll(lineDrawable.arrowList)</span><br><span class="line">        lineDrawable.arrowList.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(start: <span class="type">PointF</span>, end: <span class="type">PointF</span>,color: <span class="type">Int</span>)</span></span>: Arrow&#123;</span><br><span class="line">        <span class="keyword">return</span> add(getArrow().apply &#123;</span><br><span class="line">            onPointChange(start, end)</span><br><span class="line">            <span class="keyword">this</span>.color = color</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(startX: <span class="type">Float</span>,startY: <span class="type">Float</span>, endX: <span class="type">Float</span>, endY: <span class="type">Float</span>,color: <span class="type">Int</span>)</span></span>: Arrow&#123;</span><br><span class="line">        <span class="keyword">return</span> add(getArrow().apply &#123;</span><br><span class="line">            onPointChange(startX,startY,endX,endY)</span><br><span class="line">            <span class="keyword">this</span>.color = color</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(start: <span class="type">Point</span>, end: <span class="type">Point</span>, color: <span class="type">Int</span>)</span></span>: Arrow&#123;</span><br><span class="line">        <span class="keyword">return</span> add(getArrow().apply &#123;</span><br><span class="line">            onPointChange(start, end)</span><br><span class="line">            <span class="keyword">this</span>.color = color</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(arrow: <span class="type">Arrow</span>)</span></span>: Arrow&#123;</span><br><span class="line">        lineDrawable.arrowList.add(arrow)</span><br><span class="line">        lineDrawable.invalidateSelf()</span><br><span class="line">        arrow.id = <span class="string">"arrow:<span class="variable">$arrow</span>"</span></span><br><span class="line">        arrow.clickPointSize = <span class="number">40</span></span><br><span class="line">        arrow.viewHeight = height.toFloat()</span><br><span class="line">        <span class="keyword">return</span> arrow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private val paint = Paint()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    override fun onDraw(canvas: Canvas?) &#123;</span></span><br><span class="line"><span class="comment">//        super.onDraw(canvas)</span></span><br><span class="line"><span class="comment">//        if(canvas == null)&#123;</span></span><br><span class="line"><span class="comment">//            return</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(arrow in lineDrawable.arrowList)&#123;</span></span><br><span class="line"><span class="comment">//            canvas.drawCircle(arrow.startPoint.x,arrow.startPoint.y,5F,paint)</span></span><br><span class="line"><span class="comment">//            canvas.drawCircle(arrow.endPoint.x,arrow.endPoint.y,5F,paint)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lineDrawable.invalidateSelf()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getArrow</span><span class="params">()</span></span>: Arrow&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span>(recyclingList.isEmpty())&#123;Arrow()&#125;<span class="keyword">else</span>&#123;recyclingList.removeFirst()&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMapLineClick</span><span class="params">(arrow: <span class="type">Arrow</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(lis <span class="keyword">in</span> onMapLineClickListenerList)&#123;</span><br><span class="line">            lis.onMapLineClick(arrow)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addOnMapLineClickListener</span><span class="params">(lis: <span class="type">OnMapLineClickListener</span>)</span></span>&#123;</span><br><span class="line">        onMapLineClickListenerList.add(lis)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkOnClick</span><span class="params">(x: <span class="type">Int</span>,y: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">        invalidate()</span><br><span class="line">        TaskUtils.<span class="keyword">get</span>().runAs &#123;</span><br><span class="line">            <span class="keyword">for</span> (arrow <span class="keyword">in</span> lineDrawable.arrowList)&#123;</span><br><span class="line">                <span class="keyword">for</span>(point <span class="keyword">in</span> arrow.clickPointList)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(checkPoint(point,x, y))&#123;</span><br><span class="line">                        post &#123;</span><br><span class="line">                            onMapLineClick(arrow)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span><span class="symbol">@runAs</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            post &#123;</span><br><span class="line">                onNoMapLineClick()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkPoint</span><span class="params">(point: <span class="type">PointF</span>,x: <span class="type">Int</span>,y: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> length = Math.sqrt(<span class="number">1.0</span> * (point.x - x)*(point.x - x)</span><br><span class="line">                + (point.y - y)*(point.y - y)).toFloat()</span><br><span class="line">        <span class="keyword">return</span> length &lt;= clickRadius</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNoMapLineClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(lis <span class="keyword">in</span> onMapLineClickListenerList)&#123;</span><br><span class="line">            lis.onNoMapLineClick()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>以上就是全部内容了，可以看出上面的算法还有很多的不足。</p>
<blockquote>
<ol>
<li>点击位置的精确计算问题。<br>难点：曲线的检查并不像直线那样简单，怎么做到又精确又快？</li>
<li>绘制的冗余问题，超出屏幕的部分是应该跳过的。<br>难点：起点或者终点都不在屏幕中时，怎么判断曲线经过了屏幕？</li>
</ol>
</blockquote>
<p>但是我能力有限，没有想到更好，效率更高的解决办法。如果你有好的方案，欢迎联系我。<br>相信聪明的你可以找到我的联系方式的。</p>
<p>最后，感谢你来我的小站。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='83769e11ad8dee614a88'
        data-cs='3de1ef474db139cd0f47e8769f5afed5db7da651'
        data-r='https://github.com/lollipoppp/lollipoppp.github.io.git'
        data-o='lollipoppp'
        data-a='lollipoppp,Mr-XiaoLiang'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路"><span class="toc-number">1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计方案"><span class="toc-number">2.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算屏幕坐标"><span class="toc-number">2.1.</span> <span class="toc-text">计算屏幕坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制曲线"><span class="toc-number">2.2.</span> <span class="toc-text">绘制曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#点击事件"><span class="toc-number">2.3.</span> <span class="toc-text">点击事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全部源码"><span class="toc-number">3.</span> <span class="toc-text">全部源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遗留问题"><span class="toc-number">4.</span> <span class="toc-text">遗留问题</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-153109857-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
